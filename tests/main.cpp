/*
 * main.cpp
 *
 *  Created on: Jul 17, 2016
 *      Author: f4exb
 */


#include <iostream>
#include <sys/time.h>

#include "cauchy_256.h"

long long getUSecs()
{
    struct timeval tp;
    gettimeofday(&tp, 0);
    return (long long) tp.tv_sec * 1000000L + tp.tv_usec;
}

bool example4()
{
#pragma pack(push, 1)
    struct Sample
    {
        uint16_t i;
        uint16_t q;
    };
    struct Header
    {
        uint16_t frameIndex;
        uint8_t  blockIndex;
        uint8_t  filler[5];
    };

    static const int samplesPerBlock = (512 - sizeof(Header)) / sizeof(Sample);

    struct ProtectedBlock
    {
        Sample samples[samplesPerBlock];
    };
    struct SuperBlock
    {
        Header         header;
        ProtectedBlock protectedBlock;
    };
#pragma pack(pop)

    if (cauchy_256_init())
    {
        std::cerr << "cauchy_256_init error" << std::endl;
        return false;
    }

    // Number of bytes per file block
    int BlockBytes = sizeof(ProtectedBlock);

    // Number of data blocks
    int OriginalCount = 128;  // Superframe = set of protected frames

    // Number of additional recovery blocks generated by encoder
    int RecoveryCount = 25;

    SuperBlock txBuffer[256];
    ProtectedBlock txRecovery[256];
    const unsigned char *dataPtrs[256];
    int frameCount = 0;

    // Fill original data
    for (int i = 0; i < OriginalCount; i++)
    {
        txBuffer[i].header.frameIndex = frameCount;
        txBuffer[i].header.blockIndex = i;
        dataPtrs[i] = (const unsigned char *) &txBuffer[i].protectedBlock;

        for (int k = 0; k < samplesPerBlock; k++)
        {
            txBuffer[i].protectedBlock.samples[k].i = rand();
            txBuffer[i].protectedBlock.samples[k].q = rand();
        }
    }

    // Generate recovery data

    long long ts = getUSecs();

    if (cauchy_256_encode(OriginalCount, RecoveryCount, dataPtrs, (void *) txRecovery, BlockBytes))
    {
        std::cerr << "example4: encode failed" << std::endl;
        return false;
    }

    long long usecs = getUSecs() - ts;

    std::cerr << "Encoded in " << usecs << " microseconds" << std::endl;

    // insert recovery data in sent data
    for (int i = 0; i < RecoveryCount; i++)
    {
        txBuffer[OriginalCount + i].header.frameIndex = frameCount;
        txBuffer[OriginalCount + i].header.blockIndex = i + OriginalCount;
        txBuffer[OriginalCount + i].protectedBlock = txRecovery[i];
    }

    SuperBlock* rxBuffer = new SuperBlock[256]; // received blocks
    int nbRxBlocks = 0;

    for (int i = 0; i < OriginalCount + RecoveryCount; i++)
    {
        if (i % 6 != 4)
        //if (i != 101)
        {
            rxBuffer[nbRxBlocks] = txBuffer[i];
            nbRxBlocks++;
        }
    }

    std::cerr << "exemple4: nbRxBlocks: " << nbRxBlocks << " OriginalCount: " << OriginalCount << std::endl;

    Sample *samplesBuffer = new Sample[samplesPerBlock * OriginalCount];
    ProtectedBlock* retrievedDataBuffer = (ProtectedBlock *) samplesBuffer;
    ProtectedBlock* recoveryBuffer = new ProtectedBlock[OriginalCount];      // recovery blocks with maximum size
    bool blockZeroRetrieved = false;
    int recoveryCount = 0;
    int nbBlocks = 0;
    Block blockInfo[256];

    std::cerr << "receive..." << std::endl;

    for (int i = 0; i < nbRxBlocks; i++)
    {
        int blockIndex = rxBuffer[i].header.blockIndex;

        if (nbBlocks < OriginalCount) // not enough data store it
        {
            blockInfo[i].data = (unsigned char *) &rxBuffer[i].protectedBlock;
            blockInfo[i].row = blockIndex;

            if (blockIndex < OriginalCount)
            {
                retrievedDataBuffer[blockIndex] = rxBuffer[i].protectedBlock;
            }
            else
            {
                recoveryCount++;
            }
        }

        nbBlocks++;

        if (nbBlocks == OriginalCount)
        {
            ts = getUSecs();

            if (cauchy_256_decode(OriginalCount, RecoveryCount, blockInfo, BlockBytes))
            {
                std::cerr << "example4: decode failed" << std::endl;
                return false;
            }

            usecs = getUSecs() - ts;

            for (int ir = 0; ir < recoveryCount; ir++)
            {
                int retBlockIndex = blockInfo[OriginalCount - recoveryCount + ir].row;
                retrievedDataBuffer[retBlockIndex] = *((ProtectedBlock *) blockInfo[OriginalCount - recoveryCount + ir].data);
                std::cerr << "Recovery #" << ir << ": " << retBlockIndex << std::endl;
            }
        }
    }

    std::cerr << "final..." << std::endl;

    for (int i = 0; i < OriginalCount; i++)
    {
        bool compOKi = true;
        bool compOKq = true;

        for (int k = 0; k < samplesPerBlock; k++)
        {
            if (retrievedDataBuffer[i].samples[k].i != txBuffer[i].protectedBlock.samples[k].i)
            {
                std::cerr << i << ": error: " << k << ": i: " << retrievedDataBuffer[i].samples[k].i << "/" << txBuffer[i].protectedBlock.samples[k].i << std::endl;
                compOKi = false;
                break;
            }

            if (retrievedDataBuffer[i].samples[k].q != txBuffer[i].protectedBlock.samples[k].q)
            {
                std::cerr << i << ": error: " << k << ": q: " << retrievedDataBuffer[i].samples[k].q << "/" << txBuffer[i].protectedBlock.samples[k].q << std::endl;
                compOKq = false;
                break;
            }
        }

        if (compOKi && compOKq)
        {
            std::cerr << i << ": OK" << std::endl;
        }
    }

    std::cerr << "Decoded in " << usecs << " microseconds" << std::endl;

    delete[] samplesBuffer;
    delete[] recoveryBuffer;

    return true;
} // example4


int main()
{
    std::cerr << "example4:" << std::endl;

    if (!example4())
    {
        std::cerr << "example4 failed" << std::endl << std::endl;
        return 1;
    }

    std::cerr << "example4 successful" << std::endl;
}
